This is my linux repo!
1) semaphores is a synchronization mechanism

2) Available as kernel data structure

3) flag is incremented or decremented atomically (two operations)

struct sema
{
	flag;
	list of waiting processes;
	spin lock;
}
4) scope of flag is system

5) spin lock 


i) decide how many process can access the semaphore variable
ii) before entering the critical sections, the semephore enters the wait operation
	i) if semaphore value is > 0
		then decrement and proceed
			aftere end of critical section, increments the semaphore value, generate an event for list of waiting processes
			if the process which is in critical sections is killed by a signal, it will make rest of proc to wait
			(cfq comletely fair queue scheduler)
	ii) if 0 then the process goes to waiting queue
nice to change the priority

1) semctl is used to perform operation on semaphore
i) SETVAL use to set tha value of semaphore

semaphores are used for shareable resources not shared resources
even if a resources is not shared
not recommended to use for a resource which is always shared

GDB
use "commands" to execute multiple commands after breakpoint is hit. like printing loop or array values

Shared memory
1) it is a ranget of available physical addresses
2) created outside process context
3) scope of shaed memory is specific to each process, local or data
4) sema is mandatory for shared memory implementation
5) when shmget is called a page from page table is allocated. this page will be in lowest distance from the pages used by page
6) the buffer is allocated and cleared filled with ascii 26
7) if the creator locks it(RDONLY) only the creator can unlock it
	if other processes lock it, any other process can unlock

Threads
1) gets own stack 
2) own local vari
3) shares global varaibles
4) shares file descriptors
5) shares malloc'd data
6) signal handler code is shared but signal handlers should be registered by each thread sepearately
7) pending signal queues are different
8) timing faults and sync

return of the threads
	pthread_join(tid,return **);
1) new thread must have thread id, must exit with pthread_exit
2) the calling thread should join to simulate wait system call(wait for thread to finish execution)
3) pthread_kill

sem_int(sem_t  *sem, int pshared, unsigned int value)
pshared param controls the type of semaphore
if pshared = 0 the semaphore is local to single process , if 1 it is visible to othre processes also

sem_wait - increments the sem value by 1
sem_post - decrements the sem value by 1


pthread_create

1) thread is finish when pthread_exit()
2)

scp 120 ipaddress:\

mutex;
created by macros
faster than binary semaphores
only thread can access it
	mutex_init(mutex, attr)
	mutex_lock(mutes)
	mutex_unlock(mutex)
	mutex_destroy(mutex) 
